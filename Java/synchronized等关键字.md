#### synchronized与ReentrantLock区别



相同：都是阻塞式加锁。即一个线程获得了锁，其他线程再次获取锁时就会进入阻塞状态。

不同：

- synchronized依赖于JVM（虚拟机层），ReentrantLock依赖于API（JDK层）

- ReentrantLock增加了一些高级功能

  - 等待可中断（使用lock.lockInterruptibly()实现）

  - 可指定是公平锁（按照等待顺序来获取锁）还是非公平锁。

  - 可同时绑定多个对象，其提供了一个Condition类，用来实现分组唤醒需要唤醒的线程，synchromized是要么随机唤醒一个线程要么唤醒全部

#### synchronized实现机制：

- 同步代码块：通过monitorenter和monitorexit指令，其中monitorenter指向同步代码块的开始位置，moniterexit指令指向同步代码块的结束位置。执行到monitorenter位置时会向对象获取一个monitor对象，其中包含一个计数器，当计数器为0时可成功获取，计数器加一。执行monitorexit指令后计数器减一。其他线程要阻塞等待，直到锁被另一个线程释放为止。
- 同步方法：方法中有一个ACC_SYNCHRONIZED标识（指明该方法是一个同步方法），JVM通过该标识辨别该方法是否是一个同步方法。

#### 多线程中synchronized锁升级的原理：

​	在对象头的Mark Word中有一个threadid的字段，第一次访问时为空，jvm让其持有偏向锁，并设置threadid的值为该线程id。再次进入时会判断threadid与该线程id是否一致，一致则使用该对象。不一致则升级偏向锁为轻量级锁，（原持有偏向锁的各线程均升级为轻量级锁）通过自旋次数来获取锁，在执行一定次数依然无法获取时，轻量级锁会升级为重量级锁。

锁升级的目的是减低锁带来的性能消耗。

![4491294-e3bcefb2bacea224](D:\dailyTools\Typora\files\images\4491294-e3bcefb2bacea224.png)

#### synchronized为非公平锁的体现地方：

1. 当持有锁的线程释放锁时，线程会将threadid设置为null，此时如果正好有自旋的线程，可该线程可马上获取锁。
2. 线程获取锁失败后加入到阻塞序列中，链表的顺序与被唤醒的顺序并不一致，所以不符合谁等待时间长谁先获取锁的机制。

#### JVM对synchronized的优化？

1. 锁膨胀

   无锁-->偏向锁-->轻量级锁-->重量级锁

2. 锁消除，对于不存在竞争情况的锁可以消除。

3. 锁粗化：通过扩大锁的范围，避免反复加锁和释放锁。

4. 自旋锁与自适应自旋锁：在轻量级锁失败后，线程会进入一段时间的自旋状态，通过自旋来减少线程阻塞与切换带来的资源消耗。

   自适应自旋锁的自旋次数不是固定的，俄日是前一次同一个锁上的自旋时间及锁的拥有者决定的，这解决了自旋锁带来的缺点。

#### 为什么重量级锁的开销大？

重量级锁底层依赖于系统的同步函数实现，linux中使用pthread_mutex_t互斥锁来实现。这会涉及到用户态和内核态的切换，进程的上下文切换，这些操作比较耗时。

#### sychronized锁可以降级吗？

可以

触发时机：在全局安全点中，执行清理任务时会触发尝试降级锁。

当锁降级时，主要进行了以下操作：

1. 恢复锁对象的markword对象头
2. 重置ObjectMonitor，将ObjectMonitor放入全局空闲列表，等待后续使用。

#### ReentrantLock底层原理

ReentrantLock是一个可重入的独占锁，主要有两个特性：

- 支持公平锁 非公平锁
- 可重入

ReentrantLock实现依赖于AQS（AbstractQueuedSynchronizer）

ReentrantLock主要依赖于AQS维护一个阻塞队列，多个线程对加锁时。失败则会进入阻塞队列。等待唤醒，重新尝试加锁。

#### 说一下AQS？

1. AQS是一个锁框架，它定义了所得实现机制，并开放出扩展的地方。让子类去实现，比如我们在lock的时候，AQS开放出state字段，让子类可以根据state字段来决定是否能够获得锁，对于获取不到锁的线程AQS会自动进行管理，无需子类锁关心，这就是lock时锁的内部机制，封装得很好，又暴露出子类锁需要扩展得地方。
2. AQS底层时由**同步队列+条件队列**联手组成，同步队列管理着获取不到锁的线程的排队和释放，条件队列在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不到数据的，这时候条件队列就会管理该线程，使该线程阻塞。
   - 独占模式下，同步队列就是一个链表结构，如果一个线程来获取锁获取不到，就会被添加到这个队列中，链表中有头节点指针，尾节点指针。当该节点持续自旋获取不到后就会进入阻塞状态，等待他的前一个节点来唤醒它，他被唤醒并完成任务后会被从队列中删除，并继续唤醒他的后继节点。
   - 共享模式下，与独占式类似。
   - 共享式 独占式区别：同一时刻独占式只能有一个线程获取同步状态，而共享式可以有多个线程获取同步状态。例如读操作可以多个线程共同进行。
3. AQS围绕两个队列，提供了四大场景：获得锁、释放锁、条件队列的阻塞、条件队列的唤醒。分别对应着AQS架构图中的四种颜色的线的走向。

#### AQS对资源的共享方式？

Exclusive（独占）：ReentrantLock

Share（共享）：多个线程可同时执行Semaphore、CountDownLatch, CyclicBarrier

ReentrantReadWriteLock可看成是组合式，因为他只有在写冲突时不允许多个线程同时对某一资源进行读。

自定义同步器只需要实现共享资源state的获取和释放方式就可以。不需要考虑等待队列的维护。

#### AQS组件了解码？

- Semaphore(信号量)-允许多个线程同时访问的数量（synchronized只允许一个）
- CountDownLatch(倒计时器)：让线程等待直到倒计时结束后，在开始执行。
- CyclicBarrier(循环栅栏): 与CountDownLatch相似，但功能上更复杂强大。它可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达后才打开屏障。其构造方法CyclicBarrier(int parties)，参数表示屏障拦截的线程数量，每个线程通过调用await方法告诉CyclicBarrier我已经到达屏障。

#### ReadWriteLock是什么？

ReentrantLock某些时候有局限：如果使用ReentrantLock，可能本身为了防止线程A在写数据，线程B在读数据造成的数据不一致，但这样，如果线程C、线程D也在读数据，读数据时不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。

因此产生了读写锁。ReadWriteLock是一个读写锁接口。

ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，写于写之间会互斥，提升了读写的性能。

#### AutomicInteger类的原理？

AutomicInteger类主要利用volatile和native方法来保证原子性，从而避免synchronized的高开销，执行效率大为提升。

#### volatile关键字原理？

volatile的两层语义：

1. volatile保证变量对所有线程的可见性。当volatile变量内修改，新值对所有线程会立即更新。
2. jdk1.5以后volatile完全避免了指令重排优化，实现了有序性

**原理**：

​	获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。

lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。

#### CAS了解吗？

- 全称（compare and swap），即比较并交换。是一条CPU同步原语。

- CAS包含三个操作数：
  - 需要读写的内存值V
  - 旧的预期值A
  - 要修改的更新值B

- 当且仅当V==A时，CAS通过原子方式用新值B更新V的值。否则不会进行任何操作。

CAS并发原语体现在Java语言中的sum.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮助我们实现出CAS汇编指令。

#### 总线风暴

由于volatile的mesi缓存一致性协议需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值

解决方法：部分volatile和cas使用synchronized替换

