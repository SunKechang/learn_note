### 垃圾回收（可达性分析）

#### 如何判断一个对象是否存活？

1. 引用计数法

   给每一个对象设置一个引用计数器，当有地方引用该对象时就加一，引用失效时减一。当引用计数器为0时说明该对象没有被引用，也就是垃圾对象，等待回收。

   **缺点**：无法解决循环引用的问题

2. 可达性分析法

   从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明该对象不可用，在java中可以作为GC Roots对象的有以下几种：

   - 虚拟机栈中引用的对象
   - 方法区类静态属性引用的变量
   - 方法区常量池引用的对象
   - 本地方法栈JNI引用的对象

   当一个对象满足以上条件时，不会马上被回收，还需要进行两次标记。第一次：判断当前对象是否有finalize方法并且还方法没有被执行过，若不存在则标记为垃圾对象。若有，则进行第二次标记。第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统崩溃；如果执行了finalize方法后仍没有与GC Roots对象有直接或间接引用，则被回收。

#### 被引用的对象就一定能存活吗？

不一定。看引用类型，弱引用在GC时会被回收，软引用在内存不足时，即OOM前会被回收。但如果没有在Reference Chain中的对象一定会被回收。

#### 几种垃圾回收算法的比较？

| 回收算法类型                优点                             | 缺点                                         |                  | 适用区域 |
| ------------------------------------------------------------ | -------------------------------------------- | ---------------- | -------- |
| 标记清除算法     不需要移动对象，简单                       高效 | 标记、清楚过程效率低，产生内存碎片           |                  | 老年代   |
| 标记复制算法 清理速度快，无内存碎片                          | 内存使用率低                                 |                  | 年轻代   |
| 标记整理                                                     | 简单高效                                     | 仍需移动局部对象 | 老年代   |
| 分代收集                                                     | 集合前三种方法，实行新生代与老年代的分区方法 |                  |          |



#### 有哪几种垃圾回收器？各自的优缺点？

| 垃圾回收器类型    | 使用的回收方法 | 特点                                                         | 设置参数 | 使用区域       |
| ----------------- | -------------- | ------------------------------------------------------------ | -------- | -------------- |
| Serial            | 复制           | 单线程回收器，简单高效，停顿时间长，一般只用于客户端         |          | 年轻代         |
| ParNew            | 复制           | 多线程回收器，降低停顿时间，但增加线程上下文切换消耗         |          | 年轻代         |
| Parallel Scavenge | 复制           | 多线程回收器，追求搞吞吐量，高效利用CPU，可控制最大垃圾回收停顿时间 |          | 年轻代         |
| Serial Old        | 标记-整理      | 单线程回收器，简单高效，停顿时间长。主要用于客户端。         |          | 老年代         |
| Parallel Old      | 标记-整理      | 多线程回收器，追求高吞吐量                                   |          | 老年代         |
| CMS               | 标记-清除      | 并发回收器，可与用户线程同时运行，高并发，低停顿，CPU占用比较高，响应时间快，停顿时间短，需要Serial Old 来避免并发失败的风险 |          | 老年代         |
| G1                | 标记整理+复制  | 并发回收器，可与用户线程同时运行，基于Region的内存布局形式，高并发， 低停顿，可控的回收停顿时间 |          | 老年代，年轻代 |

CPU飙高，负载均衡策略

JVM调优命令？

- jps: JVM Process Status Tool, 显示指定系统内所有的HotSpot虚拟机进程。
- jstat(JVM statistics Monitoring): 用于监视虚拟机运行时状态信息。可以显示虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
- jmap(JVM Memory Map): 生成heap dump文件。
- jstack: 生成java虚拟机当前时刻的线程快照。可以查看各个线程的调用堆栈，可以知道没有相应的线程在后台做什么事。![image-20220404165116785](D:\dailyTools\Typora\files\images\image-20220404165116785.png)
- ![image-20220404165149477](D:\dailyTools\Typora\files\images\image-20220404165149477.png)

CMS（Concurrent Mark Sweep）回收过程？CMS问题？

1. 

- 初始标记（STW）：主要搜寻标记GC Root直接关联的下级对象。
- 并发标记：根据上一步结果，继续向下标识所有关联的对象，知道这条链走到尽头。
- 重新标记（STW， CPU停顿比初始标记稍微长，远比并发标记短）：标记与第二步同时进行的线程所产生的垃圾。
- 并发清除：清理删除阶段标记死亡的对象。

2. 问题：
   1) 并发回收导致CPU资源紧张。
   2) 无法清理浮动垃圾（无法清除并发清除阶段产生的垃圾）
   3) 并发失败（并发操作时留给程序的内存无法满足系对象的需要，会并发失败）
   4) 内存碎片（标记清除算法，可以通过规定整理的参数来决定来一次内存整理）

G1回收过程？

- 初始标记（STW）：标记与GC Root直接关联的对象。并且修改TAMS指针的值，让下一阶段用户线程并发操作时，能正确在可用的Region中分配新对象。
- 并发标记：通过可达性分析，找出要回收的对象。
- 最终标记（STW）：处理并发阶段结束后仍有引用变动的对象。
- 清理阶段（STW）：根据用户所期望的停顿时间制定回收计划，可以自由选择任意多个Region构成会收集，然后把决定回收的那部分Region的存活对象复制到空的Region中，再清理掉旧Region的全部空间。这里涉及到存活对象的移动，所以需要暂停用户线程。

G1与CMS stop the world的区别

CMS的初始标记和重新标记都会STW，他的初始标记较短，重新标记较长。

G1在初始标记、最终标记、清理阶段都会STW。两者都以降低停顿时间为目标，但是区别是G1可以根据时间预测模型来预测清理时间，可以在用户规定的停顿时间内完成垃圾回收，所以更加高级可靠。
