# Golang 面试笔记
## 基础类型
### 切片
#### 如何高效拼接字符串？
拼接方法有：
- +
- fmt.Sprintf
- strings.Builder
- bytes.Buffer
- strings.Join

|  方法  | 原理  |
| --------- | ---------- |
|+ | 遍历两个字符串，同时开辟新的空间存储两个字符串 |
| fmt.Sprintf | 采用了接口参数，需要反射获取值，性能有所损耗 |
| strings.Builder | 拼接通过WriteString()函数，内部原理为将string类型append到byte数组，返回通过函数String()，return*(*string)unsafe.Pointer(&b.buf)，直接将byte数组的指针强制类型转换为string指针并返回值 |
| bytes.Buffer | 底层也是一个byte的切片，维护一个起点off，WriteString时通过copy函数，copy会减少内存分配。返回string时使用了标准类型转换（string(b.buf[b.off:])），所以会发生内存分配 |
| strings.Join| 底层也是使用的strings.Builder，同时预先计算了长度，先扩容（Grow函数）到指定大小，再拼接，减少了内存分配。但是支持通过分隔符连接起来 |

总结：strings.Join ~ strings.Builder （它在最终获取字符串时没有分配新地址空间）> bytes.Buffer (他不需要遍历)> + > fmt.Sprintf

### nil
#### 两个nil可以不相等吗？
可以。定义了两个类型的变量，值为nil，那么比较这两个变量的时候，是不相等的。
```go
var p *int = nil
var i interface{} = nil
if(p == i){
	fmt.Println("Equal")
}
//不会输出Equal
```

## Unicode
### 什么是rune类型？
他是int32的别称。专门用于Unicode字符的记录。
```go
str := "我爱Go"
ru := []rune(str)
fmt.Println(ru[0])  //我
fmt.Println(len(ru))    //4
```

## 函数
### defer执行顺序？
a) 在return之后执行，在函数结束之前执行。
b) 执行顺序与调用顺序相反，类似栈
c) 在指定返回值的函数中可以修改返回值

```go
func test() int {
    i := 0
    defer func() {
        fmt.Println("defer1")
    }
    defer func() {
        i++
        fmt.Println("defer2")
    }
    return i
}
func main() {
    fmt.Println("return", test())
}
//打印顺序
//defer1    验证b
//defer2    验证b
//return 0  验证c
```

```go
func test() (i int) {
    i := 0
    defer func() {
        i++
        fmt.Println("defer")
    }
    return i
}
func main() {
    fmt.Println("return", test())
}
//打印顺序
//defer
//return 1  验证c
```

### 逃逸分析
> 逃逸：当一个对象的指针被多个方法或线程引用时
> 
由于栈上的变量在函数运行完后就会被自动回收，所以如果某个变量在栈上，而又被函数以外的其他地方所使用，则会导致函数外无法拿到已被回收的变量。因此Golang设计了逃逸分析，提前为变量找好位置。

**Golang会将不会被其他函数或线程引用的变量优先放在栈上，将会被其他函数或线程引用的变量优先放在堆上。**

#### 如何查看是否发生逃逸？
```go
go build -gcflags '-m -l' main.go
```
## GC&&内存

| 版本 | 方法 | 简述过程 |
|---|---|---|
| 1.3 | 标记清除法 | 1、开始STW，从根对象查找可达内存。2、开始标记。3、标记清楚。4、停止STW |
| 1.5 | 三色标记法 | 1、初始状态所有对象都是白色。2、从根对象出发扫描所有根对象，将被它引用的对象标记为灰色。3、将灰色对象引用的对象标记为灰色，原灰色对象变为黑色。4、重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾对象，进行回收。|
| 1.7 | 三色标记法 + 写屏障 | 在1.5基础上，回收过程变为并发的，且在过程中如果用户修改了对象的引用，那么会将新的引用对象也标记为灰色。 |
| 1.8 | 三色标记法 + 混合写屏障 | 在1.7基础上，将栈上对象置黑，新增加的栈对象也变黑。 |

| 版本 | 缺点 |
|---|---|
| 1.3 | 需要STW，且时间较长 |
| 1.5 | 需要STW，较1.3时间有所缩短，由于无法并发，因此可能造成，后续程序中存在对A对象的引用，但当前情况下将A对象清理掉的问题。这叫做悬挂指针，指针没有指向应该指向的对象 |
| 1.7 | 解决了1.5的问题，但由于栈上对象也被认为是根对象，所以要么为每个栈对象增加写屏障，要么STW重新扫描所有栈上对象。前者会增加写入时的额外开销，后者需要STW。Go团队选择后者。在Goroutine非常多的程序中重新扫描需要占用10～100ms时间。 |
| 1.8 | 混合写屏障保证覆盖到的对象和创建、删除的对象都是灰色，同时栈上全部置黑则解决了1.7需要重新扫描的问题。 |

1.8的GC回收过程：
- STW，开启混合写屏障，扫描栈对象；
- 将所有对象加入白色集合，从根对象开始，将其放入灰色集合。每次从灰色集合取出一个对象标记为黑色，然后遍历其子对象，标记为灰色，放入灰色集合；
如此循环直到灰色集合为空。剩余的白色对象就是需要清理的对象。
- STW，关闭混合写屏障；
- 在后台进行GC（并发）。

根对象：垃圾回收器标记时最先检查的对象。
- 全局变量：编译时期就能确定运行与程序整个生命周期的变量。
- 执行栈：每个Goroutine都包含一个执行栈，里面包含栈上的变量和指向堆内存区块的指针。
- 寄存器，寄存器维护一个指针，用于指向某些赋值器分配的内存区块。
赋值器：指代用户态的代码，即指写的程序代码。在程序的执行过程中，可能会改变对象的引用关系，或者创建新的引用。
### 什么是插入写屏障？
A对象本来指向B对象，后来用户让A对象指向了C对象。
那么在修改时就会将C对象变为灰色。

### 什么是删除写屏障？
B对象本来指向C对象，后来B对象删除对C对象的引用。
在修改时C对象会变为灰色。
### 什么是混合写屏障？
插入写屏障+删除写屏障
### 什么是内存泄漏？
- 暂时行内存泄漏
  - 获取长字符串的一部分导致长字符串未释放
  - 获取长slice一部分导致长slice未释放
  - 在长slice基础上新建slice
  以上都是获取老内存的资源，导致老内存无法释放
- 永久性内存泄漏
  - goroutine永久阻塞
  - time.Ticker未关闭（定时提示器）
  - 不正确使用Finalizer导致泄漏（可在gc时期告诉gc回收相应的对象）



## 多线程
### 如何限制使用操作系统线程的最大数？
- 设置环境变量 GOMAXPROCS
- 代码中通过runtime.GOMAXPROCS设置

如果设置GOMAXPROCS为1，则Goroutine会自己协调各线程的运行时长。

## GRPC
问题：
map的底层实现原理？如何做到多线程安全？


学习博客：https://zhuanlan.zhihu.com/p/471490292